# .github/actions/pom-variables/action.yml
name: "Extracteur Maven et Builder d'Images Docker"
description: >
  Extrait les mÃ©tadonnÃ©es Maven (version/artifactId) et gÃ©nÃ¨re automatiquement
  les noms d'images Docker selon les rÃ¨gles :
  - DOCKER_IMAGE_NAME prioritaire si dÃ©fini
  - Fallback sur l'artifactId sinon
  - Support des registres Docker optionnels

inputs:
  DOCKER_IMAGE_NAME:
    description: "Nom de base personnalisÃ© pour l'image Docker"
    required: false
    default: ""
  IMAGE_REGISTRY:
    description: "URL du registre Docker (format: registry.domain/namespace)"
    required: false
    default: ""
  VERSION_FALLBACK:
    description: "Version par dÃ©faut si non trouvÃ©e dans le POM"
    required: false
    default: "latest"

outputs:
  version:
    description: "Version extraite (projet > parent > fallback)"
    value: ${{ steps.metadata-extractor.outputs.version }}
  artifact_id:
    description: "ArtifactId du projet Maven"
    value: ${{ steps.metadata-extractor.outputs.artifact_id }}
  image_name:
    description: "Nom de base de l'image (sans version/registre)"
    value: ${{ steps.metadata-extractor.outputs.image_name }}
  full_image_name:
    description: "Nom complet avec version (format: name:version)"
    value: ${{ steps.metadata-extractor.outputs.full_image_name }}
  registry_image_name:
    description: "Nom complet avec registre (format: registry/name:version)"
    value: ${{ steps.metadata-extractor.outputs.registry_image_name }}

runs:
  using: "composite"
  steps:
    - name: "ðŸ“¦ Extraction des mÃ©tadonnÃ©es"
      id: metadata-extractor
      shell: bash
      env:
        CUSTOM_IMAGE_NAME: ${{ inputs.DOCKER_IMAGE_NAME }}
        DOCKER_REGISTRY: ${{ inputs.IMAGE_REGISTRY }}
        DEFAULT_VERSION: ${{ inputs.VERSION_FALLBACK }}
      run: |
        set -euo pipefail

        # Validation des entrÃ©es
        if [[ -n "$DOCKER_REGISTRY" && ! "$DOCKER_REGISTRY" =~ ^[a-zA-Z0-9.-]+(/[a-zA-Z0-9._-]+)?$ ]]; then
          echo "::error::[REGISTRY-ERROR] Format de registre Docker invalide"
          exit 1
        fi

        if [ ! -f pom.xml ]; then
          echo "::error file=pom.xml::[POM-ERROR] Fichier pom.xml introuvable"
          exit 1
        fi

        extract_maven_value() {
          local xpath="$1"
          local fallback="$2"
          local raw_value

          if ! raw_value=$(xmllint --xpath "$xpath" pom.xml 2>&1); then
            echo "::debug::Erreur xpath '$xpath': ${raw_value#*error: }" >&2
            echo "$fallback"
            return 0
          fi

          echo "$raw_value" | awk '{$1=$1;print}' | tr -d '\n'
        }

        version=$(extract_maven_value "//*[local-name()='project']/*[local-name()='version']/text()" "")
        [ -z "$version" ] && version=$(extract_maven_value "//*[local-name()='project']/*[local-name()='parent']/*[local-name()='version']/text()" "")
        version=${version:-$DEFAULT_VERSION}

        # Gestion des versions SNAPSHOT
        if [[ "$version" == *SNAPSHOT* ]]; then
          timestamp=$(date +%Y%m%d%H%M%S)
          version="${version//-SNAPSHOT/-$timestamp}"
          echo "::notice::Version SNAPSHOT convertie: $version"
        fi

        artifact_id=$(extract_maven_value "//*[local-name()='project']/*[local-name()='artifactId']/text()" "unknown")
        image_name=${CUSTOM_IMAGE_NAME:-$artifact_id}

        full_image_name="${image_name}:${version}"
        clean_name=$(echo "$full_image_name" | tr '[:upper:]' '[:lower:]' | tr -cd '[:alnum:]._-:' | sed 's/^[._-]//;s/[._-]$//')

        # Ajout du registre
        if [ -n "$DOCKER_REGISTRY" ]; then
          registry_image="${DOCKER_REGISTRY}/${clean_name}"
        else
          registry_image="$clean_name"
        fi

        # Tag avec hash git
        short_hash=$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")
        full_image_name_with_hash="${clean_name}-${short_hash}"

        # Outputs
        {
          echo "version=$version"
          echo "artifact_id=$artifact_id"
          echo "image_name=$image_name"
          echo "full_image_name=$clean_name"
          echo "registry_image_name=$registry_image"
          echo "full_image_name_with_hash=$full_image_name_with_hash"
        } >> $GITHUB_OUTPUT

        # Variables d'environnement
        {
          echo "VERSION=$version"
          echo "ARTIFACT_ID=$artifact_id"
          echo "IMAGE_NAME=$image_name"
          echo "FULL_IMAGE_NAME=$clean_name"
          echo "REGISTRY_IMAGE_NAME=$registry_image"
          echo "FULL_IMAGE_NAME_WITH_HASH=$full_image_name_with_hash"
        } >> $GITHUB_ENV

        # Fichiers de sortie
        mkdir -p metadata
        {
          echo "$version"
          echo "$artifact_id"
          echo "$clean_name"
          echo "$registry_image"
          echo "$full_image_name_with_hash"
        } | while read -r i content; do
          echo "$content" > "metadata/${content%%:*}.txt"
        done

        echo "::group::ðŸ“‹ MÃ©tadonnÃ©es extraites"
        printf "%-25s: %s\n" "Version" "$version"
        printf "%-25s: %s\n" "ArtifactId" "$artifact_id"
        printf "%-25s: %s\n" "Image de base" "$image_name"
        printf "%-25s: %s\n" "Tag complet" "$clean_name"
        printf "%-25s: %s\n" "Tag avec hash" "$full_image_name_with_hash"
        [ -n "$DOCKER_REGISTRY" ] && printf "%-25s: %s\n" "Avec registre" "$registry_image"
        echo "::endgroup::"

    - name: "ðŸ“¤ Archivage des rÃ©sultats"
      uses: actions/upload-artifact@v4
      with:
        name: build-metadata
        path: metadata/
        retention-days: 1

    - name: "ðŸ§¹ Nettoyage des fichiers temporaires"
      if: always()
      shell: bash
      run: |
        echo "::group::ðŸ§¹ Nettoyage des fichiers temporaires"
        if [ -d "metadata" ]; then
          echo "Suppression du dossier metadata/"
          rm -rf metadata/

          echo "VÃ©rification des fichiers rÃ©siduels"
          find . -name "*.tmp" -delete

          echo "Espace disque aprÃ¨s nettoyage :"
          df -h | grep -E 'Filesystem|/github'
        else
          echo "Aucun fichier temporaire Ã  nettoyer"
        fi
        echo "::endgroup::"
